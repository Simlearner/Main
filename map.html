<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Globale Community-Karte | RaceNet</title>
    <!-- Tailwind CSS laden -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Leaflet CSS f√ºr die Weltkarte -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
    <!-- Leaflet MarkerCluster CSS f√ºr die Pin-Gruppierung -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster/dist/MarkerCluster.css" />
    <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster/dist/MarkerCluster.Default.css" />
    <!-- Icons (lucide-react, hier simuliert durch Tailwind/Emojis) -->
    <style>
        /* Dark Mode Basisstil */
        :root {
            --map-height: calc(100vh - 80px); /* H√∂he der Karte unterhalb der Kopfzeile */
        }
        body {
            font-family: 'Inter', sans-serif;
            background-color: #000000; /* Hintergrund auf Schwarz gesetzt */
            color: #e4e4e7; /* Heller Text */
        }
        #map {
            height: var(--map-height);
            z-index: 10;
            border-radius: 0.75rem;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.5), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
        }
        /* Styling f√ºr Leaflet-Marker (Custom Icon) */
        .custom-pin {
            background-color: #9333ea; /* Lila */
            color: white;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            border: 2px solid #c084fc;
            box-shadow: 0 0 10px rgba(147, 51, 234, 0.7);
            font-size: 10px;
            font-weight: bold;
        }
        /* Hervorgehobener Pin-Stil */
        .highlight-pin {
            background-color: #f87171; /* Rot f√ºr Hervorhebung */
            color: white;
            border: 3px solid #fecaca;
            width: 30px;
            height: 30px;
            line-height: 24px;
            font-size: 14px;
        }
        /* Rennsport-Flaggen-Elemente */
        .racing-flag {
            /* Behalte den dunklen Streifen-Effekt bei, aber stelle sicher, dass er auf dem schwarzen Hintergrund funktioniert */
            background-image: linear-gradient(45deg, #1f2937 25%, transparent 25%), /* Dunkelgrau statt #1a1a2e */
                              linear-gradient(-45deg, #1f2937 25%, transparent 25%),
                              linear-gradient(45deg, transparent 75%, #1f2937 75%),
                              linear-gradient(-45deg, transparent 75%, #1f2937 75%);
            background-size: 10px 10px;
            background-position: 0 0, 0 10px, 10px -10px, -10px 0px;
        }
        /* Spezifisches Styling f√ºr die Sidebar-Pins */
        .sidebar-pin {
            cursor: pointer;
            transition: all 0.2s ease-in-out;
        }
        /* Hover-Stil wird durch die Selektion √ºberschrieben, daher muss der Standard-Hover auf der Standardklasse bleiben */
        .sidebar-pin:not(.bg-purple-600):hover {
            background-color: #4c1d95; /* Dunkleres Lila bei Hover */
            transform: translateX(5px);
        }
    </style>
</head>
<body class="antialiased h-screen flex flex-col">

    <!-- Kopfzeile -->
    <header class="bg-gray-900 shadow-xl p-4 flex justify-between items-center racing-flag">
        <h1 class="text-3xl font-bold text-white tracking-widest">
            <span class="text-purple-400">RaceNet</span> | Globale Community
        </h1>
        <button id="setPinButton"
                class="bg-purple-600 hover:bg-purple-700 text-white font-bold py-2 px-4 rounded-lg shadow-lg transition duration-300 ease-in-out transform hover:scale-105">
            üèÅ Nadel setzen
        </button>
    </header>

    <!-- Hauptinhalt: Karte und Seitenleiste -->
    <main class="flex flex-1 overflow-hidden p-4 space-x-4">
        <!-- Seitenleiste f√ºr Nicknamen und Suche -->
        <aside class="w-1/4 max-w-xs bg-gray-800 p-4 rounded-xl shadow-2xl flex flex-col space-y-4 overflow-y-auto">
            <h2 class="text-xl font-semibold text-purple-400 border-b border-purple-500 pb-2">Benutzer (Pins: <span id="pinCount">0</span>)</h2>

            <!-- Suchfeld Kontinent/Land -->
            <div class="space-y-2">
                <input type="text" id="searchLocationInput" placeholder="Suche Kontinent/Land..."
                       class="w-full p-2 rounded-lg bg-gray-700 text-white placeholder-gray-400 focus:ring-purple-500 focus:border-purple-500 border-transparent">
                <div id="searchResult" class="text-sm text-center font-medium"></div>
            </div>

            <!-- Nickname-Liste -->
            <div id="nicknameList" class="space-y-1 overflow-y-auto flex-1">
                <!-- Nicknamen werden hier eingef√ºgt -->
                <p id="noPinsMessage" class="text-gray-400 text-sm italic">Noch keine Pins gesetzt.</p>
            </div>
        </aside>

        <!-- Kartenbereich -->
        <section class="flex-1 min-w-0">
            <div id="map" class="w-full rounded-xl"></div>
        </section>
    </main>

    <!-- Modalfenster (f√ºr Nachrichten und Eingaben) - WIRD AUTOMATISCH MIT Tailwind ZENTRIERT -->
    <div id="modal" class="fixed inset-0 bg-black bg-opacity-75 hidden items-center justify-center z-50">
        <div class="bg-gray-800 p-6 rounded-xl shadow-2xl max-w-sm w-full space-y-4 border-2 border-purple-600">
            <h3 id="modalTitle" class="text-xl font-bold text-purple-400"></h3>
            <p id="modalMessage" class="text-white"></p>
            <input type="text" id="modalInput" placeholder="Dein Nickname"
                   class="w-full p-2 rounded-lg bg-gray-700 text-white placeholder-gray-400 focus:ring-purple-500 focus:border-purple-500 border-transparent">
            <div class="flex justify-end space-x-3">
                <button id="modalCancel" class="bg-gray-600 hover:bg-gray-700 text-white py-2 px-4 rounded-lg transition duration-150">
                    Abbrechen
                </button>
                <button id="modalConfirm" class="bg-purple-600 hover:bg-purple-700 text-white font-bold py-2 px-4 rounded-lg transition duration-150">
                    Best√§tigen
                </button>
            </div>
        </div>
    </div>

    <!-- Leaflet JS und MarkerCluster laden -->
    <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
    <script src="https://unpkg.com/leaflet.markercluster/dist/leaflet.markercluster.js"></script>

    <script>
        // Allgemeine Konfiguration und Initialisierung
        const mapElement = document.getElementById('map');
        const setPinButton = document.getElementById('setPinButton');
        const nicknameListDiv = document.getElementById('nicknameList');
        const searchLocationInput = document.getElementById('searchLocationInput');
        const searchResultDiv = document.getElementById('searchResult');
        const pinCountSpan = document.getElementById('pinCount');
        const noPinsMessage = document.getElementById('noPinsMessage');

        // Modal Elemente
        const modal = document.getElementById('modal');
        const modalTitle = document.getElementById('modalTitle');
        const modalMessage = document.getElementById('modalMessage');
        const modalInput = document.getElementById('modalInput');
        const modalConfirm = document.getElementById('modalConfirm');
        const modalCancel = document.getElementById('modalCancel');

        let map;
        let markers; // MarkerClusterGroup
        let userPins = []; // Speichert alle Pin-Daten
        let currentPinningNickname = null;
        let highlightedMarker = null; // Aktuell hervorgehobener Marker auf der Karte
        let selectedSidebarItem = null; // Aktuell ausgew√§hltes Element in der Seitenleiste
        let geoJsonLayer = null; // F√ºr Gebiets-Highlights (jetzt entfernt)

        // --- Hilfsfunktionen f√ºr das Modal ---

        /** Zeigt das Modal mit benutzerdefinierter Konfiguration an */
        function showModal(title, message, isInput = false, confirmCallback = null, isSpinner = false) {
            modalTitle.textContent = title;
            modalMessage.textContent = message;

            modalInput.value = '';
            modalInput.classList.toggle('hidden', !isInput);

            // Verberge Buttons und zeige Spinner, wenn geladen wird
            modalConfirm.classList.toggle('hidden', isSpinner);
            modalCancel.classList.toggle('hidden', isSpinner || !isInput);

            if (isSpinner) {
                // F√ºge einen einfachen Lade-Spinner hinzu (Tailwind-Klasse)
                modalMessage.innerHTML = `<p class="flex items-center justify-center space-x-2">${message} <svg class="animate-spin h-5 w-5 text-purple-400 ml-3" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24"><circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle><path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path></svg></p>`;
            } else {
                 modalMessage.textContent = message;
            }


            modalConfirm.onclick = () => {
                const inputValue = isInput ? modalInput.value.trim() : null;
                modal.classList.add('hidden');
                if (confirmCallback) {
                    confirmCallback(inputValue);
                }
            };
            modalConfirm.textContent = isInput ? 'Weiter' : 'OK';

            modalCancel.onclick = () => {
                modal.classList.add('hidden');
                // Setze den Pinning-Zustand zur√ºck, falls abgebrochen wird
                if (currentPinningNickname) {
                    currentPinningNickname = null;
                }
            };
            modalCancel.classList.toggle('hidden', isSpinner || !isInput); // Abbrechen nur bei Eingabe anzeigen

            modal.classList.remove('hidden');
        }

        // --- Datenverwaltung (ersetzt Google Sheets) ---

        /** L√§dt Pins aus dem localStorage */
        function loadPins() {
            try {
                const storedPins = localStorage.getItem('raceNetUserPins');
                if (storedPins) {
                    userPins = JSON.parse(storedPins);
                    console.log(`Pins geladen: ${userPins.length}`);
                } else {
                    // Startdaten f√ºr die Demo (simuliert Google Sheet-Daten)
                    userPins = [
                        { nickname: "TurboTom", lat: 52.5200, lng: 13.4050, country: "Deutschland", continent: "Europa" },
                        { nickname: "SpeedySue", lat: 34.0522, lng: -118.2437, country: "USA", continent: "Nordamerika" },
                        { nickname: "CircuitChris", lat: 35.6895, lng: 139.6917, country: "Japan", continent: "Asien" },
                        { nickname: "ApexAnna", lat: -33.8688, lng: 151.2093, country: "Australien", continent: "Australien" },
                        { nickname: "RallyRay", lat: -23.5505, lng: -46.6333, country: "Brasilien", continent: "S√ºdamerika" },
                        { nickname: "RaceRico", lat: 52.5200, lng: 13.4050, country: "Deutschland", continent: "Europa" }, // √úberlappend
                    ];
                    savePins(); // Speichere die Startdaten
                }
            } catch (error) {
                console.error("Fehler beim Laden der Pins:", error);
                userPins = [];
            }
        }

        /** Speichert Pins im localStorage */
        function savePins() {
            try {
                localStorage.setItem('raceNetUserPins', JSON.stringify(userPins));
            } catch (error) {
                console.error("Fehler beim Speichern der Pins:", error);
            }
        }

        /** F√ºgt einen neuen Pin hinzu */
        function addPin(nickname, lat, lng, country, continent) {
            if (userPins.some(p => p.nickname.toLowerCase() === nickname.toLowerCase())) {
                showModal('Fehler', `Der Nickname "${nickname}" existiert bereits.`);
                return;
            }
            userPins.push({ nickname, lat, lng, country, continent });
            savePins();
            updateMapAndSidebar();
            showModal('Erfolg!', `Willkommen, ${nickname}! Dein Standort (${country}) wurde erfolgreich gespeichert.`);
        }

        // --- Kartenlogik (Leaflet) ---

        /** Initialisiert die Karte */
        function initMap() {
            if (!mapElement) {
                console.error("Karten-Element nicht gefunden.");
                return;
            }

            // Basis-Karte (Weltansicht)
            map = L.map('map', {
                worldCopyJump: true // Erm√∂glicht das Durchbl√§ttern der Weltkarte
            }).setView([20, 0], 2); // Startansicht: Mitte der Welt, Zoomstufe 2

            // OpenStreetMap Tiles (Dark Mode-√§hnlich)
            L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png', {
                attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors &copy; <a href="https://carto.com/attributions">CARTO</a>',
                subdomains: 'abcd',
                maxZoom: 18
            }).addTo(map);

            // MarkerCluster Gruppe
            markers = L.markerClusterGroup({
                showCoverageOnHover: false,
                zoomToBoundsOnClick: true,
                spiderfyOnMaxZoom: true
            });
            map.addLayer(markers);

            // Event-Listener f√ºr das Setzen einer Nadel
            map.on('click', onMapClick);

            // Lade Pins und aktualisiere die Ansicht
            loadPins();
            updateMapAndSidebar();
        }

        /** Erstellt ein benutzerdefiniertes Pin-Icon */
        function createCustomPin(content = '‚Ä¢', isHighlighted = false) {
            return L.divIcon({
                className: `custom-pin ${isHighlighted ? 'highlight-pin' : ''}`,
                html: content,
                iconSize: isHighlighted ? [30, 30] : [20, 20],
                iconAnchor: isHighlighted ? [15, 30] : [10, 20] // Passt den Ankerpunkt an
            });
        }

        /** Aktualisiert die Karte mit Pins und die Seitenleiste */
        function updateMapAndSidebar() {
            markers.clearLayers(); // L√∂scht alle bestehenden Marker
            nicknameListDiv.innerHTML = '';
            highlightedMarker = null;
            selectedSidebarItem = null; // Auswahl zur√ºcksetzen

            if (userPins.length === 0) {
                pinCountSpan.textContent = '0';
                noPinsMessage.classList.remove('hidden');
                return;
            }
            noPinsMessage.classList.add('hidden');
            pinCountSpan.textContent = userPins.length;

            userPins.forEach(pin => {
                // Erstelle Marker
                const marker = L.marker([pin.lat, pin.lng], {
                    icon: createCustomPin(),
                    pinData: pin // Speichere die Pin-Daten direkt am Marker
                }).bindPopup(`<b>${pin.nickname}</b><br>Ort: ${pin.country || 'Unbekannt'}`);

                markers.addLayer(marker);

                // Erstelle Eintrag in der Seitenleiste
                const listItem = document.createElement('div');
                // Standardklassen: bg-gray-700 und hover-Effekt
                listItem.className = 'sidebar-pin p-2 bg-gray-700 rounded-lg hover:bg-purple-800 transition duration-150 flex justify-between items-center';
                listItem.dataset.nickname = pin.nickname; // Wichtig f√ºr die Auswahl und Filterung
                listItem.innerHTML = `<span class="font-medium">${pin.nickname}</span> <span class="text-sm text-gray-400">${pin.country}</span>`;
                listItem.addEventListener('click', () => togglePinHighlightAndZoom(pin, listItem));
                nicknameListDiv.appendChild(listItem);
            });
        }

        /**
         * Hebt einen spezifischen Benutzer-Pin auf der Karte hervor und
         * togglet die Auswahl in der Seitenleiste.
         */
        function togglePinHighlightAndZoom(pin, sidebarItem) {
            const isCurrentlySelected = selectedSidebarItem === sidebarItem;

            // 1. Alle Highlights aufheben (Karte und Sidebar)
            if (highlightedMarker) {
                highlightedMarker.setIcon(createCustomPin());
                highlightedMarker = null;
            }
            if (selectedSidebarItem) {
                // Selektionsklassen entfernen
                selectedSidebarItem.classList.remove('bg-purple-600', 'text-white');
                selectedSidebarItem.classList.add('bg-gray-700', 'hover:bg-purple-800');
                selectedSidebarItem = null;
            }

            // 2. Pr√ºfen, ob eine neue Auswahl erfolgen soll (Toggle-Logik)
            if (!isCurrentlySelected) {
                // NEU AUSW√ÑHLEN

                // 2a. Map Marker suchen und hervorheben
                let foundMarker = null;
                markers.eachLayer(layer => {
                    if (layer.options.pinData && layer.options.pinData.nickname === pin.nickname) {
                        foundMarker = layer;
                        return false; // Schleife beenden
                    }
                });

                if (foundMarker) {
                    highlightedMarker = foundMarker;
                    // Highlight setzen (gr√∂√üer und rot)
                    highlightedMarker.setIcon(createCustomPin('‚òÖ', true));
                    // Zur Position zoomen und Popup √∂ffnen
                    map.flyTo([pin.lat, pin.lng], 8);
                    highlightedMarker.openPopup();
                }

                // 2b. Sidebar Highlight setzen
                selectedSidebarItem = sidebarItem;
                selectedSidebarItem.classList.remove('bg-gray-700', 'hover:bg-purple-800');
                selectedSidebarItem.classList.add('bg-purple-600', 'text-white');

                searchResultDiv.textContent = `Pin von ${pin.nickname} hervorgehoben.`;
            } else {
                // DESELEKTIERT
                searchResultDiv.textContent = `Hervorhebung aufgehoben.`;
            }

            // Entferne eventuelle vorherige Gebiets-Highlights (immer nach Interaktion)
            clearGeoJsonLayer();
        }

        /** Entfernt die GeoJson-Highlight-Ebene (Nicht mehr f√ºr die Suche verwendet) */
        function clearGeoJsonLayer() {
            if (geoJsonLayer) {
                map.removeLayer(geoJsonLayer);
                geoJsonLayer = null;
            }
        }
        
        // --- Reverse Geocoding API Aufruf (Nominatim) ---

        /** Ruft Land und Kontinent basierend auf Koordinaten ab */
        async function reverseGeocode(lat, lng) {
            // Verwende Nominatim (OpenStreetMap) f√ºr Reverse Geocoding.
            // Achtung: √ñffentliche APIs wie Nominatim haben Ratenbegrenzungen.
            const url = `https://nominatim.openstreetmap.org/reverse?format=json&lat=${lat}&lon=${lng}&zoom=10&addressdetails=1&accept-language=de`;
            
            try {
                const response = await fetch(url);
                if (!response.ok) {
                    throw new Error('Geocoding-Netzwerkfehler.');
                }
                const data = await response.json();
                const address = data.address;

                // Extrahiere Land (bevorzugt auf Deutsch)
                const country = address.country || 'Unbekanntes Land';

                // Kontinent muss oft abgeleitet werden, da er nicht direkt zur√ºckgegeben wird (sehr vereinfacht)
                let continent = 'Unbekannter Kontinent';
                if (address.continent) {
                    continent = address.continent.replace(/ Continent$/, '');
                } else if (address.country_code) {
                    const countryCode = address.country_code.toUpperCase();
                    // Stark vereinfachtes Mapping f√ºr g√§ngige L√§nder (kann unvollst√§ndig sein)
                    const continentMap = {
                        // Europa
                        'DE': 'Europa', 'FR': 'Europa', 'GB': 'Europa', 'ES': 'Europa', 'IT': 'Europa', 'PL': 'Europa',
                        // Nordamerika
                        'US': 'Nordamerika', 'CA': 'Nordamerika', 'MX': 'Nordamerika',
                        // Asien
                        'JP': 'Asien', 'CN': 'Asien', 'IN': 'Asien', 'KR': 'Asien',
                        // Afrika
                        'EG': 'Afrika', 'ZA': 'Afrika', 'NG': 'Afrika',
                        // S√ºdamerika
                        'BR': 'S√ºdamerika', 'AR': 'S√ºdamerika', 'CO': 'S√ºdamerika',
                        // Australien/Ozeanien
                        'AU': 'Australien', 'NZ': 'Australien'
                    };
                    continent = continentMap[countryCode] || 'Unbekannter Kontinent';
                }

                return { country, continent };
            } catch (error) {
                console.error("Geocoding-Fehler:", error);
                return { country: 'Geocoding Fehler', continent: 'Geocoding Fehler' };
            }
        }

        // --- Pin-Setzen-Flow ---

        /** Startet den Pin-Setzen-Flow */
        setPinButton.addEventListener('click', () => {
            showModal(
                'Nickname eingeben',
                'Bitte gib deinen einzigartigen Nickname ein, um fortzufahren.',
                true, // Ist ein Eingabefeld
                (nickname) => {
                    if (!nickname) {
                        showModal('Abgebrochen', 'Nickname-Eingabe wurde abgebrochen.');
                        return;
                    }
                    if (userPins.some(p => p.nickname.toLowerCase() === nickname.toLowerCase())) {
                        showModal('Fehler', `Der Nickname "${nickname}" ist bereits vergeben. Bitte versuche es mit einem anderen.`);
                        currentPinningNickname = null;
                        return;
                    }
                    currentPinningNickname = nickname;
                    showModal('Karte klicken', `Hallo, ${nickname}! Klicke nun auf die Weltkarte, um deinen Wohnort zu markieren.`, false); // Kein Input beim Best√§tigen
                }
            );
        });

        /** Event-Handler f√ºr den Klick auf die Karte */
        async function onMapClick(e) {
            if (!currentPinningNickname) return; // Nur aktiv, wenn der Pin-Setzen-Flow gestartet wurde

            const { lat, lng } = e.latlng;
            const nickname = currentPinningNickname;

            // 1. Lade-Modal anzeigen
            showModal(
                'Standort wird ermittelt',
                `Suche nach Land und Kontinent f√ºr ${lat.toFixed(2)}, ${lng.toFixed(2)}...`,
                false, // Kein Input
                null,  // Kein Best√§tigungs-Callback
                true   // Ist ein Spinner/Loading
            );

            // 2. Reverse Geocoding durchf√ºhren
            const location = await reverseGeocode(lat, lng);

            // 3. Pin hinzuf√ºgen
            if (location.country.includes('Fehler')) {
                showModal('Fehler beim Standort', `Konnte den Standort f√ºr ${nickname} nicht automatisch ermitteln. Bitte versuche es erneut.`);
            } else {
                addPin(nickname, lat, lng, location.country, location.continent);
            }

            currentPinningNickname = null; // Setzen des Pins ist abgeschlossen
        }

        // --- Such- und Filterlogik (Kontinent/Land) ---

        /** F√ºhrt die Suche nach Land oder Kontinent aus und filtert die Sidebar */
        searchLocationInput.addEventListener('input', () => {
            const query = searchLocationInput.value.trim().toLowerCase();
            
            // 1. GeoJSON-Highlight entfernen (Wunsch des Benutzers)
            clearGeoJsonLayer();

            if (query.length === 0) {
                // Keine Suche: Alle Pins anzeigen
                searchResultDiv.textContent = '';
                document.querySelectorAll('.sidebar-pin').forEach(item => {
                    item.classList.remove('hidden');
                });
                pinCountSpan.textContent = userPins.length; // Gesamtzahl
                return;
            }

            let matches = 0;
            
            // 2. Sidebar-Eintr√§ge filtern
            document.querySelectorAll('.sidebar-pin').forEach(item => {
                // Den zugeh√∂rigen Pin finden (√ºber data-nickname)
                const nickname = item.dataset.nickname;
                const pin = userPins.find(p => p.nickname === nickname);

                const isMatch = pin && (
                    // Pr√ºfe, ob Land oder Kontinent die Suchanfrage enth√§lt
                    (pin.country && pin.country.toLowerCase().includes(query)) ||
                    (pin.continent && pin.continent.toLowerCase().includes(query))
                );

                if (isMatch) {
                    item.classList.remove('hidden');
                    matches++;
                } else {
                    item.classList.add('hidden');
                    // Wenn ein ausgeblendeter Pin gerade ausgew√§hlt ist, muss die Auswahl aufgehoben werden
                    if (selectedSidebarItem === item) {
                        // Ruft togglePinHighlightAndZoom auf, um die Markierung aufzuheben
                        // Da die Auswahl in diesem Fall bereits aufgehoben wurde, wird kein neues Highlight gesetzt.
                        togglePinHighlightAndZoom(pin, item); 
                    }
                }
            });
            
            // 3. Ergebnis anzeigen
            searchResultDiv.textContent = matches > 0
                ? `${matches} Pins in der Region angezeigt.`
                : 'Keine Pins in der Region gefunden.';
            
            // Zeige die Anzahl der gefundenen Pins im Titel an (w√§hrend der Filterung)
            pinCountSpan.textContent = matches;
        });

        // Initialisiere die Karte, sobald das DOM geladen ist
        window.onload = initMap;
    </script>

</body>
</html>
