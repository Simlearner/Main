<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Laptime Analyse & Quantil Visualisierung</title>
    <!-- Tailwind CSS CDN für schnelles, modernes Styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f7f9fb;
            color: #1f2937;
        }
        .quantile-line {
            position: absolute;
            top: 0;
            bottom: 0;
            width: 3px;
            z-index: 10;
        }
        /* Definiert die Höhe des Canvas-Containers */
        #chartContainer {
            height: 300px;
            max-height: 50vh;
        }
        /* Stellt sicher, dass das Canvas den Container füllt */
        #laptimeChart {
            width: 100%;
            height: 100%;
        }
    </style>
</head>
<body>

<div class="max-w-6xl mx-auto p-6 bg-white shadow-xl rounded-xl mt-10 border border-gray-200">
    <h1 class="text-3xl font-bold mb-4 text-gray-800">Rundenzeiten-Verteilungsanalyse (Smooth Curve)</h1>
    <p class="mb-6 text-gray-600">Fügen Sie die Rundenzeiten in das linke Feld und die dazugehörigen Namen in das rechte Feld ein. Die **Zeilenanzahl muss übereinstimmen**.</p>

    <!-- Eingabebereich für Zeiten und Namen -->
    <div class="grid grid-cols-2 gap-4 mb-4">
        <div>
            <label class="block text-sm font-medium text-gray-700 mb-1">Rundenzeiten (Spalte 1)</label>
            <textarea id="timeInput" rows="10" placeholder="z.B. 1:30.456, 1:31.000, INVALID, ..."
                      class="w-full p-4 border-2 border-indigo-300 rounded-lg focus:border-indigo-500 focus:ring focus:ring-indigo-200 focus:ring-opacity-50 transition duration-150 ease-in-out resize-none text-sm"></textarea>
        </div>
        <div>
            <label class="block text-sm font-medium text-gray-700 mb-1">Fahrernamen (Spalte 2)</label>
            <textarea id="nameInput" rows="10" placeholder="z.B. Max Mustermann, S. Vettel, John Doe, J. Doe (eine Zeile pro Zeit)"
                      class="w-full p-4 border-2 border-indigo-300 rounded-lg focus:border-indigo-500 focus:ring focus:ring-indigo-200 focus:ring-opacity-50 transition duration-150 ease-in-out resize-none text-sm"></textarea>
        </div>
    </div>
    
    <!-- Optionen und Analyse-Button -->
    <div class="flex flex-col sm:flex-row justify-between items-start sm:items-center mt-4 mb-4 gap-4">
        <div class="flex items-center p-3 bg-red-50 rounded-lg border border-red-200">
            <label for="removeOutliers" class="flex items-center cursor-pointer">
                <input type="checkbox" id="removeOutliers" checked class="form-checkbox h-5 w-5 text-red-600 rounded border-gray-300 focus:ring-red-500">
                <span class="ml-2 text-sm text-gray-800 font-medium">Langsame Ausreißer entfernen ($Q3 + 1.5 \times IQR$)</span>
            </label>
        </div>

        <button id="analyzeButton" onclick="analyzeLaptimes()"
                class="w-full sm:w-1/3 bg-indigo-600 text-white font-semibold py-3 px-4 rounded-lg hover:bg-indigo-700 transition duration-300 ease-in-out shadow-md hover:shadow-lg focus:outline-none focus:ring-4 focus:ring-indigo-500 focus:ring-opacity-50">
            Daten Analysieren & Visualisieren
        </button>
    </div>

    <!-- Ergebnisanzeige -->
    <div id="results" class="mt-8">
        <h2 class="text-2xl font-semibold mb-4 text-gray-700 border-b pb-2">Ergebnisse & Visualisierung</h2>
        <div id="statusMessage" class="text-red-500 font-medium hidden"></div>

        <!-- Fahrersuche und -auswahl -->
        <div id="driverSearchArea" class="hidden my-6 p-4 bg-gray-50 rounded-lg border border-gray-200">
            <h3 class="text-xl font-medium mb-3 text-gray-700">Fahrer-Vergleich</h3>
            <div class="relative">
                <input type="text" id="driverSearchInput" oninput="showSuggestions()" placeholder="Fahrernamen suchen..."
                       class="w-full p-3 border-2 border-blue-300 rounded-lg focus:border-blue-500 focus:ring focus:ring-blue-200 text-sm">
                
                <!-- Vorschläge -->
                <ul id="driverSuggestions" class="absolute z-20 w-full bg-white border border-gray-300 rounded-lg shadow-lg max-h-40 overflow-y-auto hidden mt-1">
                    <!-- Vorschläge werden hier eingefügt -->
                </ul>
            </div>
            
            <!-- Ausgewählte Fahrer -->
            <div id="selectedDriversContainer" class="mt-4 flex flex-wrap gap-2">
                <!-- Chips der ausgewählten Fahrer werden hier eingefügt -->
            </div>
        </div>


        <!-- Statistik-Tabelle -->
        <div id="statsTable" class="hidden grid grid-cols-3 gap-4 text-center mb-8">
            <div class="p-4 bg-indigo-50 rounded-lg shadow-sm">
                <p class="text-sm font-medium text-gray-500">Gültige Rundenzeiten</p>
                <p id="countOutput" class="text-3xl font-bold text-indigo-700">0</p>
            </div>
            <div class="p-4 bg-red-50 rounded-lg shadow-sm border border-red-300">
                <p class="text-sm font-medium text-gray-500">Ausreißer entfernt</p>
                <p id="outliersRemovedCountOutput" class="text-3xl font-bold text-red-700">0</p>
            </div>
             <div class="p-4 bg-indigo-50 rounded-lg shadow-sm">
                <p class="text-sm font-medium text-gray-500">Median (50. Quantil)</p>
                <p id="medianOutput" class="text-3xl font-bold text-indigo-700">-</p>
            </div>
        </div>

        <!-- Chart und Quantile -->
        <div id="chartArea" class="hidden">
            <h3 class="text-xl font-medium mb-3 text-gray-700">Verteilungskurven (Smooth Curve)</h3>
            <div id="chartContainer" class="relative w-full border border-gray-300 rounded-lg p-1 bg-white">
                <canvas id="laptimeChart"></canvas>
            </div>
            <div id="chartLegend" class="mt-2 text-sm text-gray-600">
                <span class="inline-block w-4 h-2 bg-indigo-600 mr-1 rounded"></span> Gesamtverteilung |
                <span id="legendDrivers"></span>
            </div>
            
            <div id="quantileResults" class="mt-6 bg-gray-50 p-4 rounded-lg border border-gray-200">
                <h3 class="text-xl font-medium mb-3 text-gray-700">Quantile der Gesamtverteilung</h3>
                <div class="grid grid-cols-3 gap-4">
                    <div class="text-center p-3 bg-white rounded-md shadow-sm border">
                        <p class="text-xs text-gray-500">25. Perzentil (Q1)</p>
                        <p id="q25Output" class="text-lg font-bold text-green-600">-</p>
                    </div>
                    <div class="text-center p-3 bg-white rounded-md shadow-sm border border-indigo-500">
                        <p class="text-xs text-gray-500">50. Perzentil (Median)</p>
                        <p id="q50Output" class="text-lg font-bold text-indigo-600">-</p>
                    </div>
                    <div class="text-center p-3 bg-white rounded-md shadow-sm border">
                        <p class="text-xs text-gray-500">75. Perzentil (Q3)</p>
                        <p id="q75Output" class="text-lg font-bold text-green-600">-</p>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    // --- Globale Variablen und Konstanten ---
    let allDriverData = []; // [{time: ms, name: 'Driver'}, ...]
    let finalMsTimes = [];  // Bereinigte Zeiten der Gesamtgruppe (zum Zeichnen der Hauptkurve)
    let uniqueDrivers = []; // Alle eindeutigen Fahrernamen
    let selectedDrivers = []; // Array der ausgewählten Fahrer [{name: 'Name', color: '#hex'}, ...]
    let driverColors = ['#f59e0b', '#10b981', '#ef4444', '#6366f1', '#a855f7', '#ec4899']; // Driver colors
    let driverColorIndex = 0;
    
    const chartCanvas = document.getElementById('laptimeChart');
    const ctx = chartCanvas ? chartCanvas.getContext('2d') : null;

    // --- Utility Funktionen ---

    /** Konvertiert "M:SS.mmm" in Millisekunden */
    function timeToMs(timeStr) {
        if (!timeStr) return NaN;
        const parts = timeStr.trim().split(':');
        if (parts.length !== 2) return NaN;
        
        const minutes = parseInt(parts[0], 10);
        const seconds = parseFloat(parts[1]);

        if (isNaN(minutes) || isNaN(seconds)) return NaN;
        return (minutes * 60 + seconds) * 1000;
    }

    /** Konvertiert Millisekunden zurück in eine lesbare "M:SS.mmm" Zeit */
    function msToTime(ms) {
        const totalSeconds = ms / 1000;
        const minutes = Math.floor(totalSeconds / 60);
        const seconds = totalSeconds % 60;
        return `${minutes}:${seconds.toFixed(3).padStart(6, '0')}`;
    }

    /** Berechnet das n-te Quantil einer sortierten Datenreihe */
    function quantile(sortedData, q) {
        const pos = (sortedData.length - 1) * q;
        const base = Math.floor(pos);
        const rest = pos - base;

        if (base < 0) return sortedData[0];
        if (base >= sortedData.length - 1) return sortedData[sortedData.length - 1];

        return sortedData[base] + rest * (sortedData[base + 1] - sortedData[base]);
    }

    // --- Hauptanalyse Logik ---

    function analyzeLaptimes() {
        const timeInput = document.getElementById('timeInput').value;
        const nameInput = document.getElementById('nameInput').value;
        const statusMessage = document.getElementById('statusMessage');
        const statsTable = document.getElementById('statsTable');
        const chartArea = document.getElementById('chartArea');
        const driverSearchArea = document.getElementById('driverSearchArea');
        const removeOutliersChecked = document.getElementById('removeOutliers').checked;

        // Reset UI
        statusMessage.textContent = '';
        statusMessage.classList.add('hidden');
        statsTable.classList.add('hidden');
        chartArea.classList.add('hidden');
        driverSearchArea.classList.add('hidden');

        // NEU: Splitting basierend auf Zeilenumbrüchen, um Leerzeichen in Namen zu erhalten
        const rawTimes = timeInput.split('\n').map(s => s.trim()).filter(s => s.length > 0);
        const rawNames = nameInput.split('\n').map(s => s.trim()).filter(s => s.length > 0);

        if (rawTimes.length !== rawNames.length) {
            statusMessage.textContent = 'Fehler: Die Anzahl der Rundenzeiten und Namen muss übereinstimmen. Bitte stellen Sie sicher, dass jede Zeile in beiden Feldern genau einem Eintrag entspricht.';
            statusMessage.classList.remove('hidden');
            return;
        }

        // 1. Daten in MS umwandeln und "INVALID" filtern
        allDriverData = [];
        let uniqueNames = new Set();

        rawTimes.forEach((timeStr, index) => {
            const name = rawNames[index];
            if (timeStr.toUpperCase() === 'INVALID') return;
            
            const ms = timeToMs(timeStr);
            if (!isNaN(ms) && ms > 0) {
                // allDriverData speichert den kompletten Namensstring (inkl. Kommas)
                allDriverData.push({ time: ms, name: name });
                
                // Füge alle Namen (auch komma-separierte Aliase) zur Liste der Uniques hinzu
                name.split(',').map(n => n.trim()).filter(n => n.length > 0).forEach(n => uniqueNames.add(n));
            }
        });
        
        uniqueDrivers = Array.from(uniqueNames).sort();

        if (allDriverData.length < 3) {
            statusMessage.textContent = 'Es wurden nicht genügend gültige Zeit-Name-Paare gefunden (mindestens 3 erforderlich).';
            statusMessage.classList.remove('hidden');
            return;
        }

        // 2. Sortieren und Ausreißer entfernen
        let validMsTimes = allDriverData.map(d => d.time).sort((a, b) => a - b);
        
        const initialCount = validMsTimes.length;
        finalMsTimes = [...validMsTimes];
        let outliersRemovedCount = 0;
        
        if (removeOutliersChecked && initialCount >= 4) {
            const q1_temp = quantile(validMsTimes, 0.25);
            const q3_temp = quantile(validMsTimes, 0.75);
            const iqr = q3_temp - q1_temp;
            const upperFence = q3_temp + 1.5 * iqr;

            const cleanedMsTimes = validMsTimes.filter(time => time <= upperFence);
            
            outliersRemovedCount = initialCount - cleanedMsTimes.length;
            finalMsTimes = cleanedMsTimes;

            if (finalMsTimes.length < 3) {
                 statusMessage.textContent = `ACHTUNG: Nach dem Entfernen von ${outliersRemovedCount} Ausreißern sind zu wenig gültige Zeiten übrig (mindestens 3 erforderlich).`;
                 statusMessage.classList.remove('hidden');
                 return;
            }
        }
        
        // 3. Quantile berechnen
        const count = finalMsTimes.length;
        const q25 = quantile(finalMsTimes, 0.25);
        const q50 = quantile(finalMsTimes, 0.50);
        const q75 = quantile(finalMsTimes, 0.75);

        // 4. UI aktualisieren
        document.getElementById('countOutput').textContent = count;
        document.getElementById('medianOutput').textContent = msToTime(q50);
        document.getElementById('outliersRemovedCountOutput').textContent = outliersRemovedCount;
        
        document.getElementById('q25Output').textContent = msToTime(q25);
        document.getElementById('q50Output').textContent = msToTime(q50);
        document.getElementById('q75Output').textContent = msToTime(q75);

        statsTable.classList.remove('hidden');
        chartArea.classList.remove('hidden');
        driverSearchArea.classList.remove('hidden');
        
        // 5. Chart zeichnen
        drawChart(finalMsTimes, q25, q50, q75);
    }
    
    // --- Treiber-Management ---

    function showSuggestions() {
        const input = document.getElementById('driverSearchInput').value.toLowerCase().trim();
        const suggestionsList = document.getElementById('driverSuggestions');
        suggestionsList.innerHTML = '';

        // Wir brauchen mindestens 2 Zeichen, um Vorschläge zu filtern
        if (input.length < 2) {
            suggestionsList.classList.add('hidden');
            return;
        }

        // Filtrieren Sie alle eindeutigen Namen, die den Input enthalten
        const filteredDrivers = uniqueDrivers.filter(driver => 
            driver.toLowerCase().includes(input)
        ).slice(0, 10); // Nur Top 10 anzeigen

        if (filteredDrivers.length > 0) {
            filteredDrivers.forEach(driverName => {
                const li = document.createElement('li');
                li.className = 'p-2 cursor-pointer hover:bg-indigo-100 transition duration-150 text-sm';
                li.textContent = driverName;
                li.onclick = () => addSelectedDriver(driverName);
                suggestionsList.appendChild(li);
            });
            suggestionsList.classList.remove('hidden');
        } else {
            suggestionsList.classList.add('hidden');
        }
    }

    function addSelectedDriver(driverName) {
        // Prüfe, ob Fahrer bereits ausgewählt ist
        if (selectedDrivers.some(d => d.name === driverName)) return;

        // Finde die nächste freie Farbe und erhöhe den Index
        const color = driverColors[driverColorIndex % driverColors.length];
        driverColorIndex++;

        selectedDrivers.push({ name: driverName, color: color });
        
        document.getElementById('driverSearchInput').value = '';
        document.getElementById('driverSuggestions').classList.add('hidden');
        
        updateSelectedDriversUI();
        drawChart(finalMsTimes); // Chart neu zeichnen
    }

    function removeSelectedDriver(driverName) {
        selectedDrivers = selectedDrivers.filter(d => d.name !== driverName);
        updateSelectedDriversUI();
        drawChart(finalMsTimes); // Chart neu zeichnen
    }

    function updateSelectedDriversUI() {
        const container = document.getElementById('selectedDriversContainer');
        const legend = document.getElementById('legendDrivers');
        container.innerHTML = '';
        legend.innerHTML = '';

        selectedDrivers.forEach(driver => {
            // Chip im Auswahlbereich
            const chip = document.createElement('span');
            chip.className = `inline-flex items-center text-xs font-semibold px-3 py-1 rounded-full text-white cursor-pointer transition duration-150`;
            chip.style.backgroundColor = driver.color;
            chip.textContent = driver.name;
            chip.onclick = () => removeSelectedDriver(driver.name);
            
            const removeIcon = document.createElement('span');
            removeIcon.className = 'ml-1.5 font-bold';
            removeIcon.innerHTML = '&times;';
            chip.appendChild(removeIcon);
            container.appendChild(chip);

            // Eintrag in der Legende
            const legendItem = document.createElement('span');
            legendItem.className = 'mr-2';
            legendItem.innerHTML = `<span class="inline-block w-4 h-2 mr-1 rounded" style="background-color: ${driver.color};"></span> ${driver.name}`;
            legend.appendChild(legendItem);
        });
    }


    // --- Charting (KDE Simulation) ---

    // Passt die Canvas-Größe an den Container an (für Responsivität)
    function resizeCanvas() {
        if (chartCanvas && chartCanvas.parentNode) {
            chartCanvas.width = chartCanvas.parentNode.clientWidth;
            chartCanvas.height = chartCanvas.parentNode.clientHeight;
        }
    }

    window.addEventListener('resize', () => {
        resizeCanvas();
        if (finalMsTimes.length > 0) {
            // Quantile werden nur einmal berechnet, also nur neu zeichnen
            const q25 = quantile(finalMsTimes, 0.25);
            const q50 = quantile(finalMsTimes, 0.50);
            const q75 = quantile(finalMsTimes, 0.75);
            drawChart(finalMsTimes, q25, q50, q75);
        }
    });
    
    // Hilfsfunktion zur Erstellung der geglätteten Kurve (KDE-Simulation)
    function getSmoothDistribution(times, minTime, maxTime) {
        if (times.length === 0) return [];
        
        const range = maxTime - minTime;
        const resolution = 100; // Anzahl der Datenpunkte für die Kurve
        const step = range / resolution;
        
        // Bandbreite (Smoothing Factor). Große Bandbreite = glatter
        const bandwidth = range / Math.max(10, Math.sqrt(times.length) * 2); 
        
        let distribution = [];

        for (let i = 0; i < resolution; i++) {
            const timeX = minTime + i * step;
            let density = 0;
            
            // KDE-Simulation: Für jeden Punkt X die Dichte basierend auf der Nähe aller Zeiten berechnen
            times.forEach(t => {
                // Kernel-Funktion (z.B. Gauß-Kernel vereinfacht)
                const distance = Math.abs(t - timeX);
                // Je näher t an timeX ist, desto größer der Beitrag (exponentieller Abfall)
                density += Math.exp(-0.5 * (distance / bandwidth) ** 2); 
            });

            distribution.push({ x: timeX, y: density });
        }
        return distribution;
    }

    function drawChart(data, q25, q50, q75) {
        resizeCanvas(); // Sicherstellen, dass die Größe stimmt
        if (!ctx) return;

        ctx.clearRect(0, 0, chartCanvas.width, chartCanvas.height);

        if (data.length === 0) return;

        const minTime = data[0];
        const maxTime = data[data.length - 1];
        const timeRange = maxTime - minTime;

        // Randabstand (Padding) für die Achsenbeschriftung
        const padding = { top: 10, bottom: 40, left: 60, right: 10 };
        const chartWidth = chartCanvas.width - padding.left - padding.right;
        const chartHeight = chartCanvas.height - padding.top - padding.bottom;

        // 1. Hauptverteilung (Gesamtgruppe)
        const mainDistribution = getSmoothDistribution(data, minTime, maxTime);
        let maxDensity = 0;
        mainDistribution.forEach(p => { if (p.y > maxDensity) maxDensity = p.y; });

        // 2. Fahrer-Verteilungen vorbereiten
        let driverDistributions = [];
        selectedDrivers.forEach(driver => {
            // Zeiten für den ausgewählten Fahrer finden: Vergleicht den Alias im 'name'-String des Rohdaten-Arrays
            const driverTimes = allDriverData
                .filter(d => 
                    // Sucht, ob der ausgewählte Fahrername (z.B. "J. Doe") in dem Namensstring des Datensatzes (z.B. "John Doe, J. Doe") enthalten ist
                    d.name.split(',').map(n => n.trim()).some(n => n === driver.name)
                )
                .map(d => d.time)
                .sort((a, b) => a - b);
            
            if (driverTimes.length > 0) {
                const dist = getSmoothDistribution(driverTimes, minTime, maxTime);
                driverDistributions.push({ ...driver, distribution: dist });
                // Max-Dichte der Gesamtgrafik anpassen, um alle Kurven zu berücksichtigen
                dist.forEach(p => { if (p.y > maxDensity) maxDensity = p.y; });
            }
        });


        // 3. Achsen und Beschriftungen zeichnen
        ctx.strokeStyle = '#9ca3af'; // Grau
        ctx.fillStyle = '#6b7280';
        ctx.font = '10px Inter, sans-serif';

        // X-Achse
        ctx.beginPath();
        ctx.moveTo(padding.left, chartCanvas.height - padding.bottom);
        ctx.lineTo(chartCanvas.width - padding.right, chartCanvas.height - padding.bottom);
        ctx.stroke();

        // X-Achsen Beschriftungen (Min, Median, Max)
        const xToPx = (time) => padding.left + ((time - minTime) / timeRange) * chartWidth;
        
        ctx.textAlign = 'left';
        ctx.fillText(msToTime(minTime), padding.left, chartCanvas.height - padding.bottom + 20);
        ctx.textAlign = 'right';
        ctx.fillText(msToTime(maxTime), chartCanvas.width - padding.right, chartCanvas.height - padding.bottom + 20);
        
        // Median Beschriftung
        const medianPx = xToPx(q50);
        ctx.textAlign = 'center';
        ctx.fillText(`Median: ${msToTime(q50)}`, medianPx, chartCanvas.height - padding.bottom + 35);


        // 4. Zeichne die Verteilungskurven (Hauptkurve zuerst)
        
        // Funktion zum Zeichnen einer Kurve
        const drawCurve = (distribution, color, isFill) => {
            if (distribution.length === 0) return;

            ctx.beginPath();
            ctx.strokeStyle = color;
            ctx.fillStyle = color + '20'; // 20% Transparenz für Füllung
            ctx.lineWidth = 2;

            // Starte links unten
            ctx.moveTo(padding.left, chartCanvas.height - padding.bottom); 

            distribution.forEach((p, i) => {
                const x = xToPx(p.x);
                // Skaliere die Dichte (y-Wert) auf die Chart-Höhe
                const y = chartCanvas.height - padding.bottom - (p.y / maxDensity) * chartHeight; 
                ctx.lineTo(x, y);
            });
            
            // Fülle den Bereich bis zur X-Achse
            if (isFill) {
                ctx.lineTo(chartCanvas.width - padding.right, chartCanvas.height - padding.bottom); // Ende rechts unten
                ctx.closePath();
                ctx.fill();
            }
            
            // Zeichne die Linie
            ctx.stroke();
        };

        // Hauptverteilung (mit Füllung)
        drawCurve(mainDistribution, '#4f46e5', true); // Indigo 600

        // Fahrer-Verteilungen (nur Linie)
        driverDistributions.forEach(d => {
            drawCurve(d.distribution, d.color, false);
        });

        // 5. Quantil-Linien (Q1, Q2, Q3)
        const quantiles = [
            { time: q25, color: '#10b981' }, // Green 500
            { time: q50, color: '#4f46e5' }, // Indigo 600
            { time: q75, color: '#10b981' }  // Green 500
        ];
        
        quantiles.forEach(q => {
            const x = xToPx(q.time);
            ctx.strokeStyle = q.color;
            ctx.lineWidth = 1.5;
            ctx.beginPath();
            ctx.setLineDash([5, 3]); // Gestrichelte Linie
            ctx.moveTo(x, padding.top);
            ctx.lineTo(x, chartCanvas.height - padding.bottom);
            ctx.stroke();
            ctx.setLineDash([]); // Zurücksetzen
        });
        
    }
    
    // Initialisiere die Canvas-Größe beim Laden
    window.onload = () => {
        resizeCanvas();
    };

</script>

</body>
</html>
